---
layout: post
title: "数组矩阵排序"
date: 2025-5-22 11:29:08 +0800
categories: Leetcode
---
# 根据第K场考试的分数排序

```bash
班里有 m 位学生，共计划组织 n 场考试。给你一个下标从 0 开始、大小为 m x n 的整数矩阵 score ，其中每一行对应一位学生，而 score[i][j] 表示第 i 位学生在第 j 场考试取得的分数。矩阵 score 包含的整数 互不相同 。

另给你一个整数 k 。请你按第 k 场考试分数从高到低完成对这些学生（矩阵中的行）的排序。

返回排序后的矩阵。

输入：score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2
输出：[[7,5,11,2],[10,6,9,1],[4,8,3,15]]
解释：在上图中，S 表示学生，E 表示考试。
- 下标为 1 的学生在第 2 场考试取得的分数为 11 ，这是考试的最高分，所以 TA 需要排在第一。
- 下标为 0 的学生在第 2 场考试取得的分数为 9 ，这是考试的第二高分，所以 TA 需要排在第二。
- 下标为 2 的学生在第 2 场考试取得的分数为 3 ，这是考试的最低分，所以 TA 需要排在第三。
```

## 解题心路

1. 刚开始想要for循环找列最大值，然后交换行。而且因为对语法掌握不熟练，所以不知道有更简单的方法。
2. 写好后，也发现了一些问题`score.shape[0] 和 score[:, k] 是 NumPy 风格，但题目输入的是 Python 原生 List[List[int]]，应使用原生语法。`
3. 交换 `score[[0,max_index],:] = score[[max_index,0],:]` 是 NumPy 的写法，不适用于列表。

## 知识点
1. 普通 `list[i][j]` 访问，不能用 .shape、不能切片
2. np.array([[1, 2], [3, 4]])可使用 .shape、切片 array[:, 1]、向量化运算
3. sorted(score, key=lambda x: x[k], reverse=True) 的结构：
· `sorted(...)`是python原生的排序函数，返回排序后的新列表，不会修改原列表
· `key=lambda x: x[k]` 是一个匿名函数, 按每个学生 x 的第 k 场考试成绩 `x[k]` 来排序，具体的：

```bash

lambda 参数: 返回值

所以 lambda x: x[k] 的作用就是告诉排序函数：以学生的第 k 场考试成绩作为排序的依据。
```

· `reverse=True` 从大到小排序（默认是从小到大）

## 多级排序

如果想先按第 k 场考试成绩排序，如果分数相同再按第 j 场考试成绩，可以写成：
```bash
sorted(score, key = lambda x : (x[k],x[j]), reverse=True)
```

# 按身高排序
为了巩固知识，又做了一道类似的题：

```bash
给你一个字符串数组 names ，和一个由 互不相同 的正整数组成的数组 heights 。两个数组的长度均为 n 。

对于每个下标 i，names[i] 和 heights[i] 表示第 i 个人的名字和身高。

请按身高 降序 顺序返回对应的名字数组 names 。

示例 1：

输入：names = ["Mary","John","Emma"], heights = [180,165,170]
输出：["Mary","Emma","John"]
解释：Mary 最高，接着是 Emma 和 John 。

示例 2：

输入：names = ["Alice","Bob","Bob"], heights = [155,185,150]
输出：["Bob","Alice","Bob"]
解释：第一个 Bob 最高，然后是 Alice 和第二个 Bob 。
```

## 思路
本来想先创建字典，根据字典的value值排序输出keys,但是存在一个问题，就是字典的keys一样的话，数值会覆盖
```bash
 pairs = dict(zip(names, heights))
```
所以，只需要对 (name, height) 对组成的列表进行排序，不需要转换为字典！
```bash
pairs = zip(names, heights)
sorted_pairs = sorted(pairs, key = lambda x : x[1], reverse = True)
return [name for name, _ in sorted_pairs]
```

## 知识点
这里有一个知识点`return [name for name, _ in sorted_pairs]` 是一种 列表推导式（List Comprehension）。
```bash
[表达式 for 元素 in 可迭代对象]

```
相当于写了一个 for 循环，把处理结果逐个加入列表。而代码中使用的`[name for name, _ in sorted_pairs]`是它的解包式变种：对 sorted_pairs 这个可迭代对象中的每一个元素（它是一个二元组，如 ("Bob", 185)），解包为 `name, _`（只用第一个 name，第二个 _ 忽略），把 name 放入新列表中。

### 例子
```bash
pairs = [('a', 1), ('b', 2), ('c', 3)]
result = [x for x, y in pairs]  # → ['a', 'b', 'c']
result = [y for x, y in pairs]  # → [1, 2, 3]
```
